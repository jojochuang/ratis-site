"use strict";(self.webpackChunkratis_tmp=self.webpackChunkratis_tmp||[]).push([[8021],{7692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"concepts/state-machine-snapshot","title":"State Machine Snapshot","description":"Overview","source":"@site/docs/concepts/state-machine-snapshot.md","sourceDirName":"concepts","slug":"/concepts/state-machine-snapshot","permalink":"/ratis-site/docs/concepts/state-machine-snapshot","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ratis-site/edit/main/docs/concepts/state-machine-snapshot.md","tags":[],"version":"current","frontMatter":{"title":"State Machine Snapshot"},"sidebar":"tutorialSidebar","previous":{"title":"Raft Log","permalink":"/ratis-site/docs/concepts/raft-log"},"next":{"title":"Ratis-shell CLI","permalink":"/ratis-site/docs/cli"}}');var s=n(4848),o=n(8453);const i={title:"State Machine Snapshot"},r="State Machine Snapshot",l={},h=[{value:"Overview",id:"overview",level:2},{value:"Implement snapshot",id:"implement-snapshot",level:2},{value:"Trigger a snapshot",id:"trigger-a-snapshot",level:2},{value:"Purge obsolete logs after snapshot",id:"purge-obsolete-logs-after-snapshot",level:2},{value:"Retain multiple versions of snapshot",id:"retain-multiple-versions-of-snapshot",level:2},{value:"Load the latest snapshot",id:"load-the-latest-snapshot",level:2},{value:"Customize snapshot storage path",id:"customize-snapshot-storage-path",level:2},{value:"Customize snapshot installation",id:"customize-snapshot-installation",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"state-machine-snapshot",children:"State Machine Snapshot"})}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"Raft log grows during normal operation. As it grows larger, it occupies more space and takes more time to replay. Therefore, some form of log compaction is necessary for practical systems. In Ratis, we introduce snapshot mechanism as the way to do log compaction. The basic idea of snapshot is to create and save a snapshot reflecting the latest state of the state machine, and then delete previous logs up to the checkpoint."}),"\n",(0,s.jsx)(t.h2,{id:"implement-snapshot",children:"Implement snapshot"}),"\n",(0,s.jsxs)(t.p,{children:["To enable snapshot, we have to first implement the following two methods in ",(0,s.jsx)(t.code,{children:"StateMachine"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"/**\n * Dump the in-memory state into a snapshot file in the RaftStorage. The\n * StateMachine implementation can decide 1) its own snapshot format, 2) when\n * a snapshot is taken, and 3) how the snapshot is taken (e.g., whether the\n * snapshot blocks the state machine, and whether to purge log entries after\n * a snapshot is done).\n *\n * The snapshot should include the latest raft configuration.\n *\n * @return the largest index of the log entry that has been applied to the\n * state machine and also included in the snapshot. Note the log purge\n * should be handled separately.\n */\nlong takeSnapshot() throws IOException;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"/**\n * Returns the information for the latest durable snapshot.\n */\nSnapshotInfo getLatestSnapshot();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Snapshotting for memory-based state machines is conceptually simple. In snapshotting, the entire current system state is written to a snapshot on stable storage. With disk-based state machines, a recent copy of the system state is maintained on disk as part of normal operation. Thus, the Raft log can be discarded as soon as the state machine reflects writes to disk, and snapshotting is used only when sending consistent disk images to other servers. Examples of snapshot implementation can be found at ",(0,s.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/java/org/apache/ratis/examples/arithmetic/ArithmeticStateMachine.java",children:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/java/org/apache/ratis/examples/arithmetic/ArithmeticStateMachine.java"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"trigger-a-snapshot",children:"Trigger a snapshot"}),"\n",(0,s.jsx)(t.p,{children:"To trigger a snapshot, we can either"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Trigger snapshot manually using ",(0,s.jsx)(t.code,{children:"SnapshotManagementApi"}),". Note that Ratis imposes a minimal creation gap between two subsequent snapshot creation:"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// SnapshotManagementApi\nRaftClientReply create(long timeoutMs) throws IOException;\nRaftClientReply create(boolean force, long timeoutMs) throws IOException;\nRaftClientReply create(long creationGap, long timeoutMs) throws IOException;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// customize snapshot creation gap\nRaftServerConfigKeys.Snapshot.setCreationGap(properties, 1024L);\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Enable triggering snapshot automatically when log size exceeds limit (in number of applied log entries). To do so, we may turn on the auto-trigger-snapshot option in RaftProperties and set an appropriate triggering threshold."}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"RaftServerConfigKeys.Snapshot.setAutoTriggerEnabled(properties, true);\nRaftServerConfigKeys.Snapshot.setAutoTriggerThreshold(properties, 400000);\n"})}),"\n",(0,s.jsx)(t.h2,{id:"purge-obsolete-logs-after-snapshot",children:"Purge obsolete logs after snapshot"}),"\n",(0,s.jsx)(t.p,{children:"When a snapshot is taken, Ratis will automatically discard obsolete logs. By default, Ratis will purge logs up to min(snapshot index, safe index), where safe index equals to the minimal commit index of all group members. In other words, if a log is committed by all group members and is included in the latest snapshot, then this log can be safely deleted. Sometimes we can choose to aggressively purge the logs up to the snapshot index even if some peers do not have commit index up to snapshot index. To do this, we can turn on the purge-up-to-snapshot-index option in RaftProperties:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"RaftServerConfigKeys.Log.setPurgeUptoSnapshotIndex(properties, true);\n"})}),"\n",(0,s.jsx)(t.p,{children:"Purging the logs up to snapshot index sometimes leads to unnecessary burst of network bandwidth. That is, even if a follower lags behind only a few logs, the leader still needs to transfer the full snapshot. To avoid this situation, we can preserve some recent logs when purging logs up to snapshot index. To do this, we can set the number of logs to be preserved when purging in RaftProperties:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"RaftServerConfigKeys.Log.setPurgePreservationLogNum(properties, n);\n"})}),"\n",(0,s.jsx)(t.p,{children:"Intuitively, cost of transferring n logs shall equal the cost of transferring the full snapshot."}),"\n",(0,s.jsx)(t.h2,{id:"retain-multiple-versions-of-snapshot",children:"Retain multiple versions of snapshot"}),"\n",(0,s.jsxs)(t.p,{children:["Ratis allows ",(0,s.jsx)(t.code,{children:"StateMachine"})," to retain multiple versions of snapshot. To enable this feature, we have to:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Set how many number of versions to retain in RaftProperties when building the RaftServer:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"RaftServerConfigKeys.Snapshot.setRetentionFileNum(properties, 2);\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsxs)(t.li,{children:["Implement ",(0,s.jsx)(t.code,{children:"StateMachineStorage.cleanupOldSnapshots"})," to clean up old versions of snapshot:"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// StateMachineStorage.java\nvoid cleanupOldSnapshots(SnapshotRetentionPolicy snapshotRetentionPolicy) throws IOException;\n"})}),"\n",(0,s.jsx)(t.h2,{id:"load-the-latest-snapshot",children:"Load the latest snapshot"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["When a RaftServer restarts and tries to recover the data, it first has to read and load the latest snapshot, and then apply the logs not included in the snapshot. We have to implement snapshot loading in ",(0,s.jsx)(t.code,{children:"StateMachine.initialize"})," lifecycle hook."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"/*\n * Initializes the State Machine with the given parameter.\n * The state machine must, if there is any, read the latest snapshot.\n */\nvoid initialize(RaftServer raftServer, RaftGroupId raftGroupId, RaftStorage storage) throws IOException;\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsxs)(t.li,{children:["When a RaftServer newly joins an existing cluster, it has first to obtain the latest snapshot and install it locally. Before installing a snapshot, ",(0,s.jsx)(t.code,{children:"StateMachine.pause"})," hook is called to ensure that a new snapshot can be installed."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"/*\n * Pauses the state machine. On return, the state machine should have closed all open files so\n * that a new snapshot can be installed.\n */\nvoid pause();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["After installing the snapshot, ",(0,s.jsx)(t.code,{children:"StateMachine.reinitialize"})," is called. We shall initialize the state machine with the latest installed snapshot in this lifecycle hook."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"/**\n * Re-initializes the State Machine in PAUSED state. The\n * state machine is responsible reading the latest snapshot from the file system (if any) and\n * initialize itself with the latest term and index there including all the edits.\n */\nvoid reinitialize() throws IOException;\n"})}),"\n",(0,s.jsx)(t.h2,{id:"customize-snapshot-storage-path",children:"Customize snapshot storage path"}),"\n",(0,s.jsxs)(t.p,{children:["By default, Ratis assumes ",(0,s.jsx)(t.code,{children:"StateMachine"})," snapshot files be placed under ",(0,s.jsx)(t.code,{children:"RaftStorageDirectory.getStateMachineDir()"}),". When leader installs a snapshot to the follower, Ratis will keep the snapshot layout in follower side unchanged relative to this directory. That is, the installed snapshot under follower's state machine directory will have the same hierarchy as in the leader side. ",(0,s.jsx)(t.code,{children:"StateMachine"})," can also customize the snapshot storage and install directory. To do this, we may provide the snapshot storage root directory in ",(0,s.jsx)(t.code,{children:"StateMachineStorage"}),", together with a temporary directory holding in-transmitting snapshot files."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// StateMachineStorage\n/** @return the state machine directory. */\ndefault File getSnapshotDir() {\n  return null;\n}\n\n/** @return the temporary directory. */\ndefault File getTmpDir() {\n  return null;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Examples of customizing snapshot storage path can be found at ",(0,s.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-server/src/test/java/org/apache/ratis/InstallSnapshotFromLeaderTests.java",children:"https://github.com/apache/ratis/blob/master/ratis-server/src/test/java/org/apache/ratis/InstallSnapshotFromLeaderTests.java"})]}),"\n",(0,s.jsx)(t.h2,{id:"customize-snapshot-installation",children:"Customize snapshot installation"}),"\n",(0,s.jsxs)(t.p,{children:["When a new follower joins the cluster, leader will install the latest snapshot to the follower. ",(0,s.jsx)(t.code,{children:"StateMachine"})," only needs to provide the ",(0,s.jsx)(t.code,{children:"SnapshotInfo"})," of the latest snapshot, and it's Ratis' responsibility to handle all the nuances of dividing snapshot into chunks / transferring chunks / validating checksum. This default implementation works well in most scenarios. However, there are scenarios where the default implementation cannot satisfy. To name a few:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"StateMachine"})," has a flexible snapshot layout with files scattering around different directories."]}),"\n",(0,s.jsx)(t.li,{children:"Follower wants to fully utilize underling topology. For example, follower may download the snapshot from the nearest follower instead of the leader."}),"\n",(0,s.jsx)(t.li,{children:"Follower wants to download snapshot from different sources in parallel."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Ratis provides ",(0,s.jsx)(t.code,{children:"InstallSnapshotNotification"})," to let ",(0,s.jsx)(t.code,{children:"StateMachine"})," take over the full control of snapshot installation. To enable this feature, we may first turn off the leader-install-snapshot option to disable leader explicitly installing snapshot to follower:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"RaftServerConfigKeys.Log.Appender.setInstallSnapshotEnabled(properties, false);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["After this option is disabled, Whenever the leader detects that a follower needs snapshot, instead of installing snapshot to that follower, leader will only send a snapshot installation notification. It's now the follower's responsibility to install the latest snapshot asynchronously. To do this, we have to implement ",(0,s.jsx)(t.code,{children:"FollowerEventApi.notifyInstallSnapshotFromLeader"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"interface FollowerEventApi {\n  /**\n   * Notify the {@link StateMachine} that the leader has purged entries from its log.\n   * In order to catch up, the {@link StateMachine} has to install the latest snapshot asynchronously.\n   *\n   * @param roleInfoProto information about the current node role and rpc delay information.\n   * @param firstTermIndexInLog The term-index of the first append entry available in the leader's log.\n   * @return return the last term-index in the snapshot after the snapshot installation.\n   */\n  default CompletableFuture notifyInstallSnapshotFromLeader(\n      RoleInfoProto roleInfoProto,\n      TermIndex firstTermIndexInLog) {\n    return CompletableFuture.completedFuture(null);\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Examples of ",(0,s.jsx)(t.code,{children:"notifyInstallSnapshotFromLeader"})," implementation can be found at ",(0,s.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-server/src/test/java/org/apache/ratis/InstallSnapshotNotificationTests.java",children:"https://github.com/apache/ratis/blob/master/ratis-server/src/test/java/org/apache/ratis/InstallSnapshotNotificationTests.java"})]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(6540);const s={},o=a.createContext(s);function i(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);