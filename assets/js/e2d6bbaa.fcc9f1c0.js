"use strict";(self.webpackChunkratis_tmp=self.webpackChunkratis_tmp||[]).push([[5270],{5112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"getting-started-detailed","title":"Getting Started (Detailed)","description":"Let\'s get started to use Raft in your application. To demonstrate how to use Ratis, we implement a simple Counter service, which maintains a counter value across a raft group. Clients could send the following types of requests to the raft group:","source":"@site/docs/getting-started-detailed.md","sourceDirName":".","slug":"/getting-started-detailed","permalink":"/ratis-site/docs/getting-started-detailed","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ratis-site/edit/main/docs/getting-started-detailed.md","tags":[],"version":"current","frontMatter":{"title":"Getting Started (Detailed)"},"sidebar":"tutorialSidebar","previous":{"title":"About Apache Ratis","permalink":"/ratis-site/docs/about"},"next":{"title":"Concepts","permalink":"/ratis-site/docs/concepts"}}');var r=n(4848),i=n(8453);const s={title:"Getting Started (Detailed)"},o="Getting Started",l={},c=[{value:"Adding the Dependency",id:"adding-the-dependency",level:2},{value:"Implementing the <code>CounterStateMachine</code>",id:"implementing-the-counterstatemachine",level:2},{value:"Defining the State",id:"defining-the-state",level:3},{value:"Applying Raft Log Entries",id:"applying-raft-log-entries",level:3},{value:"Processing Readonly Commands",id:"processing-readonly-commands",level:3},{value:"Taking Snapshots",id:"taking-snapshots",level:3},{value:"Loading Snapshots",id:"loading-snapshots",level:3},{value:"Implementing the <code>initialize</code> and <code>reinitialize</code> methods.",id:"implementing-the-initialize-and-reinitialize-methods",level:3},{value:"Preparing a <code>RaftGroup</code>",id:"preparing-a-raftgroup",level:2},{value:"Building &amp; Starting the <code>CounterServer</code>",id:"building--starting-the-counterserver",level:2},{value:"Building &amp; Running the <code>CounterClient</code>",id:"building--running-the-counterclient",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"getting-started",children:"Getting Started"})}),"\n",(0,r.jsxs)(t.p,{children:["Let's get started to use Raft in your application. To demonstrate how to use Ratis, we implement a simple ",(0,r.jsx)(t.em,{children:"Counter"})," service, which maintains a counter value across a raft group. Clients could send the following types of requests to the raft group:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"INCREMENT"}),": increase the counter value by 1. This command will trigger a transaction to change the state."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"GET"}),": query the current value of the counter. This is a read-only command since it does not change the state."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We have the following ",(0,r.jsx)(t.code,{children:"enum"})," for representing the supported commands."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"/**\n * The supported commands the Counter example.\n */\npublic enum CounterCommand {\n  /** Increment the counter by 1. */\n  INCREMENT,\n  /** Get the counter value. */\n  GET;\n\n  private final Message message = Message.valueOf(name());\n\n  public Message getMessage() {\n    return message;\n  }\n\n  /** Does the given command string match this command? */\n  public boolean matches(String command) {\n    return name().equalsIgnoreCase(command);\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Note: The source code of the Counter example and the other examples is at ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/tree/master/ratis-examples",children:"Ratis examples"}),". This article intends to show the steps of integration of Ratis. If you wish to run the Counter example please refer to ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/tree/master/ratis-examples#example-3-counter",children:"the README"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"adding-the-dependency",children:"Adding the Dependency"}),"\n",(0,r.jsxs)(t.p,{children:["The first step is to add Ratis dependencies into the project. The dependencies are available in ",(0,r.jsx)(t.a,{href:"https://search.maven.org/search?q=g:org.apache.ratis",children:"maven central"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:"<dependency>\n   <artifactId>ratis-server</artifactId>\n   <groupId>org.apache.ratis</groupId>\n</dependency>\n"})}),"\n",(0,r.jsx)(t.p,{children:"Then, add one of the following transports:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"ratis-grpc"}),"\n",(0,r.jsx)(t.li,{children:"ratis-netty"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"In this example, we choose to use ratis-grpc:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:"<dependency>\n   <artifactId>ratis-grpc</artifactId>\n   <groupId>org.apache.ratis</groupId>\n</dependency>\n"})}),"\n",(0,r.jsxs)(t.h2,{id:"implementing-the-counterstatemachine",children:["Implementing the ",(0,r.jsx)(t.code,{children:"CounterStateMachine"})]}),"\n",(0,r.jsx)(t.p,{children:"A state machine manages the application logic. The state machine is responsible for:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Apply raft log transactions in order to maintain the current state.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["When there is an ",(0,r.jsx)(t.code,{children:"INCREMENT"})," request, it will first be written to the raft log as a log entry. Once the log entry is committed, the state machine will be invoked for applying the log entry as a transaction so that the counter value will be increased by 1."]}),"\n",(0,r.jsxs)(t.li,{children:["When there is a ",(0,r.jsx)(t.code,{children:"GET"})," request, it will not be written to the raft log since it is a readonly request which does not change the state. The state machine should return the current value of the counter."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Manage snapshots loading/saving.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Snapshots are used for log compaction so that the state machine can be restored from a snapshot and then applies only the newer log entries, instead of applying a long history of log starting from the beginning."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We discuss how to implement ",(0,r.jsx)(t.code,{children:"CounterStateMachine"})," in the following subsections. The complete source code of it is in ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/java/org/apache/ratis/examples/counter/server/CounterStateMachine.java",children:"CounterStateMachine.java"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"defining-the-state",children:"Defining the State"}),"\n",(0,r.jsxs)(t.p,{children:["In this example, the ",(0,r.jsx)(t.code,{children:"CounterStateMachine"})," extends the ",(0,r.jsx)(t.code,{children:"BaseStateMachine"}),", which provides a base implementation of a ",(0,r.jsx)(t.code,{children:"StateMachine"}),". Inside the ",(0,r.jsx)(t.code,{children:"CounterStateMachine"}),", there is a ",(0,r.jsx)(t.code,{children:"counter"})," object which stores the current value. The ",(0,r.jsx)(t.code,{children:"counter"})," is an ",(0,r.jsx)(t.code,{children:"AtomicInteger"})," in order to support concurrent access. We use the build-in ",(0,r.jsx)(t.code,{children:"SimpleStateMachineStorage"}),", which is a file-based storage implementation, as a storage for storing snapshots. The fields are shown below:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public class CounterStateMachine extends BaseStateMachine {\n  // ...\n  private final SimpleStateMachineStorage storage = new SimpleStateMachineStorage();\n  private final AtomicInteger counter = new AtomicInteger(0);\n  // ...\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"applying-raft-log-entries",children:"Applying Raft Log Entries"}),"\n",(0,r.jsxs)(t.p,{children:["Once a raft log entry has been committed (i.e. a majority of the servers have acknowledged), Ratis notifies the state machine by invoking the ",(0,r.jsx)(t.code,{children:"applyTransaction"})," method. The ",(0,r.jsx)(t.code,{children:"applyTransaction"})," method first validates the log entry. Then, it applies the log entry by increasing the counter value and updates the term-index. The code fragments are shown below. Note that the ",(0,r.jsx)(t.code,{children:"incrementCounter"})," method is synchronized in order to update both counter and last applied term-index atomically."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'public class CounterStateMachine extends BaseStateMachine {\n  // ...\n  private synchronized int incrementCounter(TermIndex termIndex) {\n    updateLastAppliedTermIndex(termIndex);\n    return counter.incrementAndGet();\n  }\n\n  // ...\n\n  /**\n   * Apply the {@link CounterCommand#INCREMENT} by incrementing the counter object.\n   *\n   * @param trx the transaction context\n   * @return the message containing the updated counter value\n   */\n  @Override\n  public CompletableFuture applyTransaction(TransactionContext trx) {\n    final LogEntryProto entry = trx.getLogEntry();\n    //check if the command is valid\n    final String command = entry.getStateMachineLogEntry().getLogData().toString(Charset.defaultCharset());\n    if (!CounterCommand.INCREMENT.match(command)) {\n      return JavaUtils.completeExceptionally(new IllegalArgumentException("Invalid Command: " + command));\n    }\n    //increment the counter and update term-index\n    final TermIndex termIndex = TermIndex.valueOf(entry);\n    final long incremented = incrementCounter(termIndex);\n    //if leader, log the incremented value and the term-index\n    if (trx.getServerRole() == RaftPeerRole.LEADER) {\n      LOG.info("{}: Increment to {}", termIndex, incremented);\n    }\n    //return the new value of the counter to the client\n    return CompletableFuture.completedFuture(Message.valueOf(String.valueOf(incremented)));\n  }\n\n  // ...\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"processing-readonly-commands",children:"Processing Readonly Commands"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"INCREMENT"})," command is implemented in the previous section. What about the ",(0,r.jsx)(t.code,{children:"GET"})," command? Since the ",(0,r.jsx)(t.code,{children:"GET"})," command is a readonly command, it is implemented by the ",(0,r.jsx)(t.code,{children:"query"})," method instead of the ",(0,r.jsx)(t.code,{children:"applyTransaction"})," method. The code fragment is shown below."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'public class CounterStateMachine extends BaseStateMachine {\n  // ...\n  /**\n   * Process {@link CounterCommand#GET}, which gets the counter value.\n   *\n   * @param request the GET request\n   * @return a {@link Message} containing the current counter value as a {@link String}.\n   */\n  @Override\n  public CompletableFuture query(Message request) {\n    final String command = request.getContent().toString(Charset.defaultCharset());\n    if (!CounterCommand.GET.match(command)) {\n      return JavaUtils.completeExceptionally(new IllegalArgumentException("Invalid Command: " + command));\n    }\n    return CompletableFuture.completedFuture(Message.valueOf(counter.toString()));\n  }\n\n  // ...\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"taking-snapshots",children:"Taking Snapshots"}),"\n",(0,r.jsxs)(t.p,{children:["When taking a snapshot, the state is persisted in the storage of the state machine. The snapshot can be loaded for restoring the state in the future. In this example, we use ",(0,r.jsx)(t.code,{children:"ObjectOutputStream"})," to write the counter value to a snapshot file. The term-index is stored in the file name of the snapshot file. The code fragments are shown below. Note that the ",(0,r.jsx)(t.code,{children:"getState"})," method is synchronized in order to get the applied term-index and the counter value atomically. Note also that getting the counter value alone does not have to be synchronized since the ",(0,r.jsx)(t.code,{children:"counter"})," field is already an ",(0,r.jsx)(t.code,{children:"AtomicInteger"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'public class CounterStateMachine extends BaseStateMachine {\n  // ...\n  /** The state of the {@link CounterStateMachine}. */\n  static class CounterState {\n    private final TermIndex applied;\n    private final int counter;\n\n    CounterState(TermIndex applied, int counter) {\n      this.applied = applied;\n      this.counter = counter;\n    }\n\n    TermIndex getApplied() {\n      return applied;\n    }\n\n    int getCounter() {\n      return counter;\n    }\n  }\n\n  // ...\n\n  /** @return the current state. */\n  private synchronized CounterState getState() {\n    return new CounterState(getLastAppliedTermIndex(), counter.get());\n  }\n\n  // ...\n\n  /**\n   * Store the current state as a snapshot file in the {@link #storage}.\n   *\n   * @return the index of the snapshot\n   */\n  @Override\n  public long takeSnapshot() {\n    //get the current state\n    final CounterState state = getState();\n    final long index = state.getApplied().getIndex();\n    //create a file with a proper name to store the snapshot\n    final File snapshotFile = storage.getSnapshotFile(state.getApplied().getTerm(), index);\n    //write the counter value into the snapshot file\n    try (ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(\n        Files.newOutputStream(snapshotFile.toPath())))) {\n      out.writeInt(state.getCounter());\n    } catch (IOException ioe) {\n      LOG.warn("Failed to write snapshot file \\"" + snapshotFile + "\\", last applied index=" + state.getApplied());\n    }\n    //return the index of the stored snapshot (which is the last applied one)\n    return index;\n  }\n\n  // ...\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"loading-snapshots",children:"Loading Snapshots"}),"\n",(0,r.jsxs)(t.p,{children:["When loading a snapshot, we use an ",(0,r.jsx)(t.code,{children:"ObjectInputStream"})," to read the snapshot file. The term-index is read from the file name of the snapshot file. The code fragments are shown below. Note that the ",(0,r.jsx)(t.code,{children:"updateState"})," method is synchronized in order to update the applied term-index and the counter value atomically."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'public class CounterStateMachine extends BaseStateMachine {\n  // ...\n  private synchronized void updateState(TermIndex applied, int counterValue) {\n    updateLastAppliedTermIndex(applied);\n    counter.set(counterValue);\n  }\n\n  // ...\n\n  /**\n   * Load the state of the state machine from the {@link #storage}.\n   *\n   * @param snapshot the information of the snapshot being loaded\n   * @return the index of the snapshot or -1 if snapshot is invalid\n   * @throws IOException if it failed to read from storage\n   */\n  private long load(SingleFileSnapshotInfo snapshot) throws IOException {\n    //check null\n    if (snapshot == null) {\n      LOG.warn("The snapshot info is null.");\n      return RaftLog.INVALID_LOG_INDEX;\n    }\n    //check if the snapshot file exists.\n    final Path snapshotPath = snapshot.getFile().getPath();\n    if (!Files.exists(snapshotPath)) {\n      LOG.warn("The snapshot file {} does not exist for snapshot {}", snapshotPath, snapshot);\n      return RaftLog.INVALID_LOG_INDEX;\n    }\n    //read the TermIndex from the snapshot file name\n    final TermIndex last = SimpleStateMachineStorage.getTermIndexFromSnapshotFile(snapshotPath.toFile());\n    //read the counter value from the snapshot file\n    try (ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(Files.newInputStream(snapshotPath)))) {\n      counterValue = in.readInt();\n    }\n    //update state\n    updateState(last, counterValue);\n    return last.getIndex();\n  }\n\n  // ...\n}\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"implementing-the-initialize-and-reinitialize-methods",children:["Implementing the ",(0,r.jsx)(t.code,{children:"initialize"})," and ",(0,r.jsx)(t.code,{children:"reinitialize"})," methods."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"initialize"})," method is called at most once when the server is starting up. In contrast, the ",(0,r.jsx)(t.code,{children:"reinitialize"})," method is called when 1. the server is resumed from the ",(0,r.jsx)(t.code,{children:"PAUSE"})," state, or 2. a new snapshot is installed from the leader or from an external source. In ",(0,r.jsx)(t.code,{children:"CounterStateMachine"}),", the ",(0,r.jsx)(t.code,{children:"reinitialize"})," method simply loads the latest snapshot and the ",(0,r.jsx)(t.code,{children:"initialize"})," method additionally initializes the ",(0,r.jsx)(t.code,{children:"BaseStateMachine"})," super class and the storage."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public class CounterStateMachine extends BaseStateMachine {\n  // ...\n  /**\n   * Initialize the state machine storage and then load the state.\n   *\n   * @param server the server running this state machine\n   * @param groupId the id of the {@link org.apache.ratis.protocol.RaftGroup}\n   * @param raftStorage the storage of the server\n   * @throws IOException if it fails to load the state.\n   */\n  @Override\n  public void initialize(RaftServer server, RaftGroupId groupId, RaftStorage raftStorage) throws IOException {\n    super.initialize(server, groupId, raftStorage);\n    storage.init(raftStorage);\n    reinitialize();\n  }\n\n  /**\n   * Simply load the state.\n   *\n   * @throws IOException if it fails to load the state.\n   */\n  @Override\n  public void reinitialize() throws IOException {\n    load(storage.getLatestSnapshot());\n  }\n\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(t.h2,{id:"preparing-a-raftgroup",children:["Preparing a ",(0,r.jsx)(t.code,{children:"RaftGroup"})]}),"\n",(0,r.jsxs)(t.p,{children:["In order to run a raft group, each server must start a ",(0,r.jsx)(t.code,{children:"RaftServer"})," instance, which is responsible for communicating to each other through the Raft protocol. It's important to keep in mind that, each raft server knows the initial raft group when starting up. They know the number of raft peers in the group and the addresses of the peers. In this example, we have a raft group with 3 peers. For simplicity, each peer listens to a specific port on the same machine. The addresses of them are defined in a ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/resources/conf.properties",children:"property file"})," as below."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-properties",children:"raft.server.address.list=127.0.0.1:10024,127.0.0.1:10124,127.0.0.1:11124\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The peers are named as 'n0', 'n1' and 'n2' and they form a ",(0,r.jsx)(t.code,{children:"RaftGroup"}),". For more details, see ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/java/org/apache/ratis/examples/common/Constants.java",children:"Constants.java"}),"."]}),"\n",(0,r.jsxs)(t.h2,{id:"building--starting-the-counterserver",children:["Building & Starting the ",(0,r.jsx)(t.code,{children:"CounterServer"})]}),"\n",(0,r.jsxs)(t.p,{children:["We use a ",(0,r.jsx)(t.code,{children:"RaftServer.Builder"})," to build a ",(0,r.jsx)(t.code,{children:"RaftServer"}),". We first set up a ",(0,r.jsx)(t.code,{children:"RaftProperties"})," object with a local directory as the storage of the server and a port number as the gRPC server port. Then, we create our ",(0,r.jsx)(t.code,{children:"CounterStateMachine"})," and pass everything to the builder as below."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public final class CounterServer implements Closeable {\n  private final RaftServer server;\n\n  public CounterServer(RaftPeer peer, File storageDir) throws IOException {\n    //create a property object\n    final RaftProperties properties = new RaftProperties();\n    //set the storage directory (different for each peer) in the RaftProperty object\n    RaftServerConfigKeys.setStorageDir(properties, Collections.singletonList(storageDir));\n    //set the port (different for each peer) in RaftProperty object\n    final int port = NetUtils.createSocketAddr(peer.getAddress()).getPort();\n    GrpcConfigKeys.Server.setPort(properties, port);\n    //create the counter state machine which holds the counter value\n    final CounterStateMachine counterStateMachine = new CounterStateMachine();\n    //build the Raft server\n    this.server = RaftServer.newBuilder()\n        .setGroup(Constants.RAFT_GROUP)\n        .setProperties(properties)\n        .setServerId(peer.getId())\n        .setStateMachine(counterStateMachine)\n        .build();\n  }\n\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now we are ready to start our ",(0,r.jsx)(t.code,{children:"CounterServer"})," peers and form a raft group. The command is:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",children:"java org.apache.ratis.examples.counter.server.CounterServer peer_index\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The argument ",(0,r.jsx)(t.code,{children:"peer_index"})," must be 0, 1 or 2. After a server is started, it communicates with other peers in the group, and performs raft actions such as leader election and append-log-entries. After all three servers are started, the counter service is up and running with the Raft protocol. For more details, see ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/java/org/apache/ratis/examples/counter/server/CounterServer.java",children:"CounterServer.java"}),"."]}),"\n",(0,r.jsxs)(t.h2,{id:"building--running-the-counterclient",children:["Building & Running the ",(0,r.jsx)(t.code,{children:"CounterClient"})]}),"\n",(0,r.jsxs)(t.p,{children:["We use a ",(0,r.jsx)(t.code,{children:"RaftGroup"})," to build a ",(0,r.jsx)(t.code,{children:"RaftClient"})," and then use the ",(0,r.jsx)(t.code,{children:"RaftClient"})," to send commands to the raft service. Note that gRPC is the default RPC type so that we may skip setting it in the ",(0,r.jsx)(t.code,{children:"RaftProperties"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public final class CounterClient implements Closeable {\n  private final RaftClient client = RaftClient.newBuilder()\n      .setProperties(new RaftProperties())\n      .setRaftGroup(Constants.RAFT_GROUP)\n      .build();\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["With this raft client, we can then send commands using the ",(0,r.jsx)(t.code,{children:"BlockingApi"})," returned by ",(0,r.jsx)(t.code,{children:"RaftClient.io()"}),", or the ",(0,r.jsx)(t.code,{children:"AsyncApi"})," returned by ",(0,r.jsx)(t.code,{children:"RaftClient.async()"}),". The ",(0,r.jsx)(t.code,{children:"send"})," method in the ",(0,r.jsx)(t.code,{children:"BlockingApi"}),"/",(0,r.jsx)(t.code,{children:"AsyncApi"})," is used to send the ",(0,r.jsx)(t.code,{children:"INCREMENT"})," command as below."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"client.io().send(CounterCommand.INCREMENT.getMessage());\n"})}),"\n",(0,r.jsx)(t.p,{children:"or"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"client.async().send(CounterCommand.INCREMENT.getMessage());\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"sendReadonly"})," method in the ",(0,r.jsx)(t.code,{children:"BlockingApi"}),"/",(0,r.jsx)(t.code,{children:"AsyncApi"})," is used to send the ",(0,r.jsx)(t.code,{children:"GET"})," command as below."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"client.io().sendReadOnly(CounterCommand.GET.getMessage());\n"})}),"\n",(0,r.jsx)(t.p,{children:"or"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"client.async().sendReadOnly(CounterCommand.GET.getMessage());\n"})}),"\n",(0,r.jsxs)(t.p,{children:["For more details, see ",(0,r.jsx)(t.a,{href:"https://github.com/apache/ratis/blob/master/ratis-examples/src/main/java/org/apache/ratis/examples/counter/client/CounterClient.java",children:"CounterClient.java"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(6540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);