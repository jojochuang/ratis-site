"use strict";(self.webpackChunkratis_tmp=self.webpackChunkratis_tmp||[]).push([[6213],{8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}},9802:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"concepts/raft-log","title":"Raft Log","description":"The Raft Log is the central data structure in Ratis that ensures consistency and fault tolerance. It is an append-only log of operations that are applied to the state machine. The log is replicated across all the servers in a Raft group, and an entry is only considered \\"committed\\" when it has been successfully replicated to a majority of the servers.","source":"@site/docs/concepts/raft-log.md","sourceDirName":"concepts","slug":"/concepts/raft-log","permalink":"/ratis-site/docs/concepts/raft-log","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ratis-site/edit/main/docs/concepts/raft-log.md","tags":[],"version":"current","frontMatter":{"title":"Raft Log"},"sidebar":"tutorialSidebar","previous":{"title":"Concepts","permalink":"/ratis-site/docs/concepts"},"next":{"title":"State Machine Snapshot","permalink":"/ratis-site/docs/concepts/state-machine-snapshot"}}');var i=n(4848),o=n(8453);const a={title:"Raft Log"},r="The Raft Log",l={},c=[{value:"Raft Log Implementations",id:"raft-log-implementations",level:2},{value:"1. <code>MemoryRaftLog</code>",id:"1-memoryraftlog",level:3},{value:"2. <code>SegmentedRaftLog</code>",id:"2-segmentedraftlog",level:3},{value:"Key Concepts",id:"key-concepts",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"the-raft-log",children:"The Raft Log"})}),"\n",(0,i.jsx)(t.p,{children:'The Raft Log is the central data structure in Ratis that ensures consistency and fault tolerance. It is an append-only log of operations that are applied to the state machine. The log is replicated across all the servers in a Raft group, and an entry is only considered "committed" when it has been successfully replicated to a majority of the servers.'}),"\n",(0,i.jsx)(t.h2,{id:"raft-log-implementations",children:"Raft Log Implementations"}),"\n",(0,i.jsxs)(t.p,{children:["Ratis provides two primary implementations of the ",(0,i.jsx)(t.code,{children:"RaftLog"})," interface:"]}),"\n",(0,i.jsxs)(t.h3,{id:"1-memoryraftlog",children:["1. ",(0,i.jsx)(t.code,{children:"MemoryRaftLog"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Description:"})," This is a simple, in-memory implementation of the Raft Log. It stores all log entries in a list in the Java heap."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Use Case:"})," The ",(0,i.jsx)(t.code,{children:"MemoryRaftLog"})," is primarily used for testing and is ",(0,i.jsx)(t.strong,{children:"not recommended for production use"}),". Since it does not persist data to disk, all log entries will be lost if the server restarts."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Performance:"})," It is extremely fast due to its in-memory nature, but it does not provide any durability guarantees."]}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"2-segmentedraftlog",children:["2. ",(0,i.jsx)(t.code,{children:"SegmentedRaftLog"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Description:"})," This is the production-ready, disk-based implementation of the Raft Log. It stores log entries in a series of segmented files on disk. Each segment has a configurable maximum size, and when a segment is full, a new one is created."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Use Case:"})," The ",(0,i.jsx)(t.code,{children:"SegmentedRaftLog"})," is the default and recommended implementation for production environments. It provides the durability and fault tolerance guarantees that are expected from a Raft-based system."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Performance:"})," While not as fast as the ",(0,i.jsx)(t.code,{children:"MemoryRaftLog"}),", the ",(0,i.jsx)(t.code,{children:"SegmentedRaftLog"})," is highly optimized for performance. It uses a combination of in-memory caching and efficient disk I/O to provide a good balance between performance and durability."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Log Index:"})," Each entry in the Raft Log is assigned a unique, monotonically increasing log index."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Term:"})," A term is a logical clock in Raft that is used to detect stale leaders. Each term has a single leader, and the term number increases whenever a new leader is elected."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Commit Index:"}),' The commit index is the highest log index that is known to be replicated on a majority of the servers. Log entries up to the commit index are considered "committed" and can be safely applied to the state machine.']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Snapshotting:"})," To prevent the Raft Log from growing indefinitely, Ratis uses snapshotting. A snapshot is a point-in-time copy of the state machine's state. Once a snapshot is taken, all the log entries up to that point can be safely discarded."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);