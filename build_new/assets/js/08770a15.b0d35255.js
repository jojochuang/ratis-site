"use strict";(self.webpackChunkratis_tmp=self.webpackChunkratis_tmp||[]).push([[6686],{5698:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"features/ratis-streaming","title":"Ratis Streaming","description":"For information on how to configure Ratis Streaming, please see the Streaming Configuration tutorial.","source":"@site/docs/features/ratis-streaming.md","sourceDirName":"features","slug":"/features/ratis-streaming","permalink":"/ratis-site/docs/features/ratis-streaming","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ratis-site/edit/main/docs/features/ratis-streaming.md","tags":[],"version":"current","frontMatter":{"title":"Ratis Streaming"},"sidebar":"tutorialSidebar","previous":{"title":"Rolling Upgrade and Rollback","permalink":"/ratis-site/docs/features/rolling-upgrade-rollback"},"next":{"title":"Support Priority in Leader Election","permalink":"/ratis-site/docs/features/leader-election-priority"}}');var r=n(4848),a=n(8453);const s={title:"Ratis Streaming"},o="Ratis Streaming",l={},d=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Proposed Solution: Ratis Streaming",id:"proposed-solution-ratis-streaming",level:2},{value:"Implementation Plan",id:"implementation-plan",level:2},{value:"Step 1: Streaming (without Topology Change)",id:"step-1-streaming-without-topology-change",level:3},{value:"Step 2: Pipeline (Topology Change)",id:"step-2-pipeline-topology-change",level:3},{value:"Transport Mechanism",id:"transport-mechanism",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"ratis-streaming",children:"Ratis Streaming"})}),"\n",(0,r.jsxs)(t.p,{children:["For information on how to configure Ratis Streaming, please see the ",(0,r.jsx)(t.a,{href:"/ratis-site/docs/developer-guide/streaming-configuration",children:"Streaming Configuration"})," tutorial."]}),"\n",(0,r.jsx)(t.p,{children:"Ratis Streaming is a feature designed to optimize the handling of client requests in a Raft cluster, addressing limitations of the traditional star topology where all client requests are sent directly to the Leader."}),"\n",(0,r.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(t.p,{children:["The traditional Raft approach, where clients send requests to the Leader and the Leader then forwards them as ",(0,r.jsx)(t.code,{children:"appendEntries"})," to all followers in a star topology, has several drawbacks:"]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Increased Leader Memory Cache:"})," The Leader requires significant memory to cache outstanding client requests and log entries/data for each follower. Retrying mechanisms can exacerbate this by caching the same data multiple times."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance Bottlenecks:"})," Concurrent requests can be slowed down if a client's data is written to a slower disk, impacting other clients even if they are writing to faster disks."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Suboptimal Streaming Performance:"})," The traditional method is not ideal for streaming data, as it requires waiting for incoming streams to close before processing, unlike true streaming where data can be immediately forwarded."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Inefficient Network Traffic for Leader:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The Leader directly receives all requests from all clients, leading to a high number of connections to manage."}),"\n",(0,r.jsxs)(t.li,{children:["The Leader uses twice or more network bandwidth compared to followers for ",(0,r.jsx)(t.code,{children:"appendEntries"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Suboptimal Network Topology Utilization:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Clients near a follower but far from the Leader still have to send requests to the Leader, which then sends ",(0,r.jsx)(t.code,{children:"appendEntries"})," back to the near follower."]}),"\n",(0,r.jsx)(t.li,{children:"Inefficiencies arise when the Leader resides in a different rack than co-located followers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"proposed-solution-ratis-streaming",children:"Proposed Solution: Ratis Streaming"}),"\n",(0,r.jsx)(t.p,{children:"Ratis Streaming aims to overcome these limitations by introducing pipelines (or spanning trees) instead of a star topology for broadcasting client requests. In this model, all machines (Leader and followers) can directly receive requests from clients and then stream these requests to other machines using a pipeline."}),"\n",(0,r.jsx)(t.p,{children:"For example, if the Leader and Follower 1 are in the same rack, and Follower 2 is in a different rack:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"*   **Case 1 (Traditional):** Client -> Leader -> Follower 1 ---------------\x3e Follower 2\n*   **Case 2 (Streaming):** Leader <- Follower 1 <--------------- Follower 2 <- Client\n*   **Case 3 (Streaming with Pipeline):** Client -> Follower 1 -> Leader ---------------\x3e Follower 2\n"})}),"\n",(0,r.jsx)(t.p,{children:"When the Leader receives a forwarded request, it processes it as usual. When a follower receives a request, it sends an acknowledgment to the Leader, and the Leader replies with the log index."}),"\n",(0,r.jsx)(t.h2,{id:"implementation-plan",children:"Implementation Plan"}),"\n",(0,r.jsx)(t.p,{children:"The implementation of Ratis Streaming is divided into two main steps:"}),"\n",(0,r.jsx)(t.h3,{id:"step-1-streaming-without-topology-change",children:"Step 1: Streaming (without Topology Change)"}),"\n",(0,r.jsx)(t.p,{children:"This step focuses on the core streaming implementation while maintaining the Ratis star topology and without considering network awareness. It addresses problems related to Leader memory cache, concurrent request ordering, and basic streaming performance."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Plan 1: Stream to the Leader, then immediately stream to followers without creating Ratis transactions."})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Clients stream requests to the Leader."}),"\n",(0,r.jsx)(t.li,{children:"The Leader immediately streams the data to all followers in parallel."}),"\n",(0,r.jsx)(t.li,{children:"A Ratis transaction is created only after the client closes the stream."}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Packet Acknowledgements:"})," The Leader acknowledges each packet back to the client only after receiving acknowledgments from all followers. This throttles traffic based on the slowest follower."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Multiple Clients:"})," Multiple clients can stream in parallel without interfering with each other until a transaction is created."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Plan 1.1: Stream to a primary node, then immediately stream to remaining nodes."})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Clients can stream to any node (Primary node), not just the Leader."}),"\n",(0,r.jsx)(t.li,{children:"The Primary node immediately streams client data to all other nodes."}),"\n",(0,r.jsx)(t.li,{children:"The Leader (which may or may not be the Primary node) creates a transaction upon receiving all stream data."}),"\n",(0,r.jsx)(t.li,{children:"Clients can continue streaming to the Primary node even during leader re-election. If the Primary node fails, the client can failover to any other node with unacknowledged data."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"step-2-pipeline-topology-change",children:"Step 2: Pipeline (Topology Change)"}),"\n",(0,r.jsx)(t.p,{children:"This step focuses on replacing the star topology with pipelines to improve network efficiency, especially in multi-rack environments. The goal is to eliminate redundant cross-rack traffic by chaining nodes in a pipeline."}),"\n",(0,r.jsx)(t.h2,{id:"transport-mechanism",children:"Transport Mechanism"}),"\n",(0,r.jsx)(t.p,{children:"Netty is chosen for the initial Streaming implementation due to its superior performance (approximately 5x better than gRPC with Protobuf or Flatbuffers) as it supports zero buffer copying."}),"\n",(0,r.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/ratis-site/docs/developer-guide/streaming-configuration",children:"Streaming Configuration"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://issues.apache.org/jira/browse/RATIS-979",children:"RATIS-979"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(6540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);