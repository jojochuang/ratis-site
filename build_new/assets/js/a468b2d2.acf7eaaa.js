"use strict";(self.webpackChunkratis_tmp=self.webpackChunkratis_tmp||[]).push([[1896],{2797:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"developer-guide/watch-requests","title":"Watch Requests","description":"The AsyncApi.watch() method is a powerful feature for clients that need to wait for a specific log index to be replicated to a certain level. This is particularly useful in scenarios where a client has submitted a write request and wants to be notified when that write has been safely replicated to a quorum of servers. Instead of polling, the client can use watch() to receive a future that will be completed when the desired replication level is reached.","source":"@site/docs/developer-guide/watch-requests.md","sourceDirName":"developer-guide","slug":"/developer-guide/watch-requests","permalink":"/ratis-site/docs/developer-guide/watch-requests","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ratis-site/edit/main/docs/developer-guide/watch-requests.md","tags":[],"version":"current","frontMatter":{"title":"Watch Requests"},"sidebar":"tutorialSidebar","previous":{"title":"Security Developer Guide","permalink":"/ratis-site/docs/developer-guide/security"},"next":{"title":"Group Management","permalink":"/ratis-site/docs/developer-guide/group-management"}}');var r=n(4848),s=n(8453);const a={title:"Watch Requests"},l="Watch Requests Developer Guide",o={},c=[{value:"The <code>watch()</code> Method",id:"the-watch-method",level:2},{value:"How to Use <code>watch()</code>",id:"how-to-use-watch",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"watch-requests-developer-guide",children:"Watch Requests Developer Guide"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"AsyncApi.watch()"})," method is a powerful feature for clients that need to wait for a specific log index to be replicated to a certain level. This is particularly useful in scenarios where a client has submitted a write request and wants to be notified when that write has been safely replicated to a quorum of servers. Instead of polling, the client can use ",(0,r.jsx)(t.code,{children:"watch()"})," to receive a future that will be completed when the desired replication level is reached."]}),"\n",(0,r.jsxs)(t.h2,{id:"the-watch-method",children:["The ",(0,r.jsx)(t.code,{children:"watch()"})," Method"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"CompletableFuture<RaftClientReply> watch(long index, ReplicationLevel replication);\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"index"})}),": The log index to be watched."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"replication"})}),": The replication level required (e.g., ",(0,r.jsx)(t.code,{children:"MAJORITY"}),", ",(0,r.jsx)(t.code,{children:"ALL"}),")."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Returns"}),": A ",(0,r.jsx)(t.code,{children:"CompletableFuture<RaftClientReply>"}),". When this future completes successfully, the ",(0,r.jsx)(t.code,{children:"RaftClientReply"})," will contain the log index that satisfied the watch request. This returned index will be greater than or equal to the index that was requested to be watched."]}),"\n"]}),"\n",(0,r.jsxs)(t.h2,{id:"how-to-use-watch",children:["How to Use ",(0,r.jsx)(t.code,{children:"watch()"})]}),"\n",(0,r.jsxs)(t.p,{children:["Here is an example of how to use the ",(0,r.jsx)(t.code,{children:"watch()"})," method:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'import org.apache.ratis.client.api.AsyncApi;\nimport org.apache.ratis.protocol.Message;\nimport org.apache.ratis.protocol.RaftClientReply;\nimport org.apache.ratis.proto.RaftProtos.ReplicationLevel;\n\nimport java.util.concurrent.CompletableFuture;\n\n// ...\n\nAsyncApi asyncApi = client.async();\n\n// 1. Send a write request\nCompletableFuture<RaftClientReply> writeFuture = asyncApi.send(Message.valueOf("my-data"));\n\n// 2. Get the log index from the reply\nwriteFuture.thenCompose(reply -> {\n    if (reply.isSuccess()) {\n        long logIndex = reply.getLogIndex();\n        System.out.println("Write request submitted with log index: " + logIndex);\n\n        // 3. Watch the log index for majority replication\n        return asyncApi.watch(logIndex, ReplicationLevel.MAJORITY);\n    } else {\n        // Handle write failure\n        return CompletableFuture.failedFuture(reply.getException());\n    }\n}).thenAccept(watchReply -> {\n    if (watchReply.isSuccess()) {\n        System.out.println("Log index " + watchReply.getLogIndex() + " has been replicated to a majority.");\n    } else {\n        // Handle watch failure\n        System.err.println("Failed to watch log index: " + watchReply.getException());\n    }\n});\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var i=n(6540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);